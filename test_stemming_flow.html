<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stemming Flow Test</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background-color: #f5f5f5;
    }
    .test-section {
      background: white;
      padding: 20px;
      margin: 10px 0;
      border-radius: 5px;
      border-left: 4px solid #4CAF50;
    }
    .test-section h3 {
      margin-top: 0;
      color: #333;
    }
    .result {
      background: #f9f9f9;
      padding: 10px;
      margin: 5px 0;
      border-radius: 3px;
      font-family: monospace;
      font-size: 12px;
      white-space: pre-wrap;
      word-break: break-all;
    }
    .pass {
      border-left: 4px solid #4CAF50;
      background: #f1f8f3;
    }
    .fail {
      border-left: 4px solid #f44336;
      background: #fef5f5;
    }
    h1 {
      color: #333;
      border-bottom: 2px solid #4CAF50;
      padding-bottom: 10px;
    }
  </style>
</head>
<body>
  <h1>MixRead Stemming Implementation Test</h1>

  <div class="test-section">
    <h3>Test 1: Stemmer.stem() Function</h3>
    <div id="test1-results"></div>
  </div>

  <div class="test-section">
    <h3>Test 2: createStemMapping() Function</h3>
    <div id="test2-results"></div>
  </div>

  <div class="test-section">
    <h3>Test 3: Real Text Example</h3>
    <div id="test3-results"></div>
  </div>

  <div class="test-section">
    <h3>Test 4: Stem-to-Variant Expansion</h3>
    <div id="test4-results"></div>
  </div>

  <script src="/Users/yinshucheng/code/creo/MixRead/frontend/scripts/stemmer.js"></script>
  <script>
    // Include the createStemMapping function from content.js
    function createStemMapping(words) {
      const stemMap = {};
      for (const word of words) {
        const stem = Stemmer.stem(word);
        if (!stemMap[stem]) {
          stemMap[stem] = [];
        }
        stemMap[stem].push(word);
      }
      return stemMap;
    }

    // Test 1: Basic stemming
    function test1() {
      const testCases = [
        { word: "strangers", expected: "stranger" },
        { word: "dropped", expected: "drop" },
        { word: "drops", expected: "drop" },
        { word: "dropping", expected: "drop" },
        { word: "pulled", expected: "pull" },
        { word: "pulling", expected: "pull" },
        { word: "walked", expected: "walk" },
        { word: "walking", expected: "walk" },
        { word: "running", expected: "run" },
        { word: "ran", expected: "ran" },  // irregular - won't be stemmed
        { word: "quickly", expected: "quick" },
        { word: "slowly", expected: "slow" },
      ];

      let results = [];
      let passCount = 0;

      testCases.forEach(tc => {
        const result = Stemmer.stem(tc.word);
        const passed = result === tc.expected;
        if (passed) passCount++;

        results.push({
          word: tc.word,
          result: result,
          expected: tc.expected,
          passed: passed
        });
      });

      document.getElementById('test1-results').innerHTML =
        `<div class="result ${passCount === testCases.length ? 'pass' : 'fail'}">
        Passed: ${passCount}/${testCases.length}
        ${results.map(r => `${r.word} → ${r.result} ${r.passed ? '✓' : '✗ (expected: ' + r.expected + ')'}`).join('\n')}
        </div>`;
    }

    // Test 2: Stem mapping
    function test2() {
      const words = ["drop", "dropped", "drops", "dropping", "pull", "pulled", "pulling"];
      const stemMap = createStemMapping(words);

      const expectedStems = ["drop", "pull"];
      const actualStems = Object.keys(stemMap).sort();
      const stemmingCorrect = JSON.stringify(expectedStems.sort()) === JSON.stringify(actualStems);

      document.getElementById('test2-results').innerHTML =
        `<div class="result ${stemmingCorrect ? 'pass' : 'fail'}">
        Input words: ${words.join(', ')}

        Stem mapping result:
        ${Object.entries(stemMap).map(([stem, variants]) =>
          `  ${stem}: [${variants.join(', ')}]`
        ).join('\n')}
        </div>`;
    }

    // Test 3: Real text example
    function test3() {
      const sampleText = "The strangers dropped their bags and pulled up their sleeves while walking slowly.";

      // Simple tokenizer
      const wordPattern = /\b[a-z''-]+\b/gi;
      const words = [];
      let match;
      while ((match = wordPattern.exec(sampleText)) !== null) {
        words.push(match[0]);
      }

      const uniqueWords = [...new Set(words)];
      const stemMap = createStemMapping(uniqueWords);

      document.getElementById('test3-results').innerHTML =
        `<div class="result pass">
        Sample text: "${sampleText}"

        Extracted words (${uniqueWords.length}): ${uniqueWords.join(', ')}

        Stem mapping (${Object.keys(stemMap).length} unique stems):
        ${Object.entries(stemMap).map(([stem, variants]) =>
          `  ${stem}: [${variants.join(', ')}]`
        ).join('\n')}
        </div>`;
    }

    // Test 4: Expand stems back to variants (simulating API response)
    function test4() {
      const words = ["drop", "dropped", "drops", "dropping", "stranger", "strangers"];
      const stemMap = createStemMapping(words);

      // Simulate API returning these stems as highlighted
      const highlightedStems = ["drop", "stranger"];

      // Expand back to variants
      const highlightedVariants = [];
      highlightedStems.forEach(stem => {
        const variants = stemMap[stem] || [stem];
        highlightedVariants.push(...variants);
      });

      document.getElementById('test4-results').innerHTML =
        `<div class="result pass">
        Original words: ${words.join(', ')}

        API returns highlighted stems: ${highlightedStems.join(', ')}

        Expanded back to variants for highlighting: ${highlightedVariants.join(', ')}

        Coverage: ${highlightedVariants.length}/${words.length} words highlighted
        (${(highlightedVariants.length / words.length * 100).toFixed(0)}%)
        </div>`;
    }

    // Run all tests
    window.addEventListener('DOMContentLoaded', () => {
      test1();
      test2();
      test3();
      test4();
    });
  </script>
</body>
</html>
